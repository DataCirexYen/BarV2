// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {TimeLockedStakingNFT} from "../src/TimeLockedStakingNFT.sol";
import {RewardSource} from "../src/RewardSource.sol";
import {ERC20} from "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import {Math} from "openzeppelin-contracts/contracts/utils/math/Math.sol";
import {console} from "forge-std/console.sol";

contract MockToken is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract TimeLockedStakingNFTRenewalTest is Test {

    MockToken internal token;
    TimeLockedStakingNFT internal staking;
    RewardSource internal rewardSource;

    address internal constant ALICE = address(0xA11CE);
    address internal constant BOB = address(0xB0B);
    address internal constant JIM = address(0xBEEF);
    address internal constant CAROL = address(0xCAFE);
    address internal constant KATE = address(0xC0DE);

    uint256 internal constant PRECISION = 1e18;
    uint256 internal constant ALICE_AMOUNT = 400 ether;
    uint256 internal constant BOB_AMOUNT = 120 ether;
    uint256 internal constant JIM_AMOUNT = 600 ether;
    uint256 internal constant CAROL_AMOUNT = 90 ether;
    uint256 internal constant KATE_AMOUNT = 200 ether;
    uint256 internal constant REWARD_FIRST_WEEK = 300 ether;
    uint256 internal constant REWARD_SECOND_WEEK = 210 ether;
    uint256 internal constant REWARD_THIRD_WEEK = 180 ether;

    function setUp() public {
        token = new MockToken();
        staking = new TimeLockedStakingNFT(token, _defaultBoostFactors());
        rewardSource = new RewardSource(token);
        staking.setRewardSource(address(rewardSource));

        rewardSource.setAllowance(address(staking), type(uint256).max);

        token.mint(ALICE, 1_000 ether);
        token.mint(BOB, 1_000 ether);
        token.mint(JIM, 1_000 ether);
        token.mint(CAROL, 1_000 ether);
        token.mint(KATE, 1_000 ether);
        token.mint(address(rewardSource), REWARD_FIRST_WEEK + REWARD_SECOND_WEEK);

        vm.prank(ALICE);
        token.approve(address(staking), type(uint256).max);
        vm.prank(BOB);
        token.approve(address(staking), type(uint256).max);
        vm.prank(JIM);
        token.approve(address(staking), type(uint256).max);
        vm.prank(CAROL);
        token.approve(address(staking), type(uint256).max);
        vm.prank(KATE);
        token.approve(address(staking), type(uint256).max);
    }

    function testBobRenewsWhileAliceIdleAndJimAnchorsMonthTier() public {
        // Alice locks for one week at the epoch start and never withdraws.
        vm.prank(ALICE);
        uint256 aliceTokenId = staking.deposit(ALICE_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneWeek);
        assertEq(_unlock(aliceTokenId), 1 weeks);
        assertEq(staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek), ALICE_AMOUNT);
        assertEq(
            staking.expiredSharesAtSlot(TimeLockedStakingNFT.LockPeriod.OneWeek, _unlock(aliceTokenId)),
            ALICE_AMOUNT
        );

        // Jim provides long-term liquidity in the month tier.
        vm.prank(JIM);
        uint256 jimTokenId = staking.deposit(JIM_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneMonth);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth),
            Math.mulDiv(JIM_AMOUNT, PRECISION, _entryNav(jimTokenId))
        );

        // Bob begins his first 1-day lock near the end of week 1 for the renewal cycle.
        vm.warp(1 weeks - 1 days);
        vm.prank(BOB);
        uint256 bobWeekOneTokenId =
            staking.deposit(BOB_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneDay);
        assertEq(_unlock(bobWeekOneTokenId), 1 weeks);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay),
            Math.mulDiv(BOB_AMOUNT, PRECISION, _entryNav(bobWeekOneTokenId))
        );

        // Enter week 2: distribute rewards. Only Jim should accrue NAV because Alice expired
        // and Bob's initial day lock already rolled into the expired bucket.
        vm.warp(1 weeks + 1 minutes);
        staking.distributeRewards(REWARD_FIRST_WEEK);

        uint256 monthNavAfterFirstWeek = PRECISION
            + Math.mulDiv(
                REWARD_FIRST_WEEK,
                PRECISION,
                staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth)
            );
        assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneDay), PRECISION);
        assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek), PRECISION);
        assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth), monthNavAfterFirstWeek);

        // Bob renews by exiting and entering again as the second week advances.
        vm.prank(BOB);
        staking.withdraw(bobWeekOneTokenId);
        assertEq(staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay), 0);
        uint256 bobInitialBalance = token.balanceOf(BOB);

        // Bob starts the next renewal on what corresponds to the second week.
        vm.warp(2 weeks - 1 days);
        vm.prank(BOB);
        uint256 bobWeekTwoTokenId =
            staking.deposit(BOB_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneDay);
        uint256 bobWeekTwoUnlock = _unlock(bobWeekTwoTokenId);
        assertEq(bobWeekTwoUnlock, 2 weeks);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay),
            Math.mulDiv(BOB_AMOUNT, PRECISION, _entryNav(bobWeekTwoTokenId))
        );

        // Before the second week ends, distribute incentives to day + month tiers.
        vm.warp(2 weeks - 12 hours);
        staking.distributeRewards(REWARD_SECOND_WEEK);

        {
            uint256 dayRewardShare =
                Math.mulDiv(REWARD_SECOND_WEEK, BOB_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
            uint256 monthRewardShare =
                Math.mulDiv(REWARD_SECOND_WEEK, JIM_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
            uint256 expectedDayNav = PRECISION + Math.mulDiv(dayRewardShare, PRECISION, BOB_AMOUNT);
            uint256 expectedMonthNav = monthNavAfterFirstWeek
                + Math.mulDiv(monthRewardShare, PRECISION, JIM_AMOUNT);

            assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneDay), expectedDayNav);
            assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek), PRECISION);
            assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth), expectedMonthNav);
        }

        // Alice remains expired but never withdrawn.
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek), ALICE_AMOUNT
        );
        assertEq(
            staking.expiredSharesAtSlot(TimeLockedStakingNFT.LockPeriod.OneWeek, 1 weeks),
            ALICE_AMOUNT
        );

        // Bob waits until the unlock slot closes and exits, capturing his proportional rewards.
        vm.warp(2 weeks + 1 minutes);
        assertEq(
            staking.expiredSharesAtSlot(
                TimeLockedStakingNFT.LockPeriod.OneDay, bobWeekTwoUnlock
            ),
            BOB_AMOUNT
        );

        vm.prank(BOB);
        staking.withdraw(bobWeekTwoTokenId);
        uint256 bobFinalBalance = token.balanceOf(BOB);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay), 0
        );
        assertEq(
            staking.expiredSharesAtSlot(
                TimeLockedStakingNFT.LockPeriod.OneDay, bobWeekTwoUnlock
            ),
            0
        );

        {
            uint256 dayRewardShare =
                Math.mulDiv(REWARD_SECOND_WEEK, BOB_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
            uint256 expectedDayNav = PRECISION + Math.mulDiv(dayRewardShare, PRECISION, BOB_AMOUNT);
            uint256 expectedBobGain =
                Math.mulDiv(expectedDayNav - PRECISION, BOB_AMOUNT, PRECISION);
            assertEq(bobFinalBalance - bobInitialBalance, expectedBobGain);
        }
        assertEq(token.balanceOf(address(rewardSource)), 0);

        {
            uint256 dayRewardShare =
                Math.mulDiv(REWARD_SECOND_WEEK, BOB_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
            uint256 monthRewardShare =
                Math.mulDiv(REWARD_SECOND_WEEK, JIM_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
            uint256 expectedDust = REWARD_SECOND_WEEK - dayRewardShare - monthRewardShare;
            assertEq(staking.rewardDust(), expectedDust);
        }

        // A day-tier staker remains idle past the fourth week without withdrawing.
        vm.warp(4 weeks - 12 hours);
        vm.prank(CAROL);
        uint256 carolTokenId = staking.deposit(CAROL_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneDay);
        assertEq(_unlock(carolTokenId), 4 weeks);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay),
            Math.mulDiv(CAROL_AMOUNT, PRECISION, _entryNav(carolTokenId))
        );

        // KATE provides the only fresh liquidity heading into the fifth week.
        vm.warp(4 weeks);
        vm.prank(KATE);
        uint256 kateTokenId = staking.deposit(KATE_AMOUNT, TimeLockedStakingNFT.LockPeriod.OneWeek);
        assertEq(_unlock(kateTokenId), 5 weeks);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek),
            Math.mulDiv(ALICE_AMOUNT, PRECISION, _entryNav(aliceTokenId))
                + Math.mulDiv(KATE_AMOUNT, PRECISION, _entryNav(kateTokenId))
        );

        token.mint(address(rewardSource), REWARD_THIRD_WEEK);

        // Enter the fourth week boundary and distribute new rewards using prior dust.
        vm.warp(4 weeks + 1 minutes);
        staking.distributeRewards(REWARD_THIRD_WEEK);

        uint256 dayRewardShare2 =
            Math.mulDiv(REWARD_SECOND_WEEK, BOB_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
        uint256 monthRewardShare2 =
            Math.mulDiv(REWARD_SECOND_WEEK, JIM_AMOUNT, BOB_AMOUNT + JIM_AMOUNT);
        uint256 expectedDust2 = REWARD_SECOND_WEEK - dayRewardShare2 - monthRewardShare2;
        uint256 totalThirdReward = REWARD_THIRD_WEEK + expectedDust2;
        uint256 weekNavDeltaThird = Math.mulDiv(totalThirdReward, PRECISION, KATE_AMOUNT);
        uint256 expectedWeekNavAfterThird = PRECISION + weekNavDeltaThird;

        {
            uint256 expectedDayNav2 = PRECISION
                + Math.mulDiv(
                    Math.mulDiv(REWARD_SECOND_WEEK, BOB_AMOUNT, BOB_AMOUNT + JIM_AMOUNT),
                    PRECISION,
                    BOB_AMOUNT
                );
            assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneDay), expectedDayNav2);
        }
        assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek), expectedWeekNavAfterThird);
        {
            uint256 expectedMonthNav2 = (PRECISION
                + Math.mulDiv(
                    REWARD_FIRST_WEEK,
                    PRECISION,
                    staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth)
                )) + Math.mulDiv(
                Math.mulDiv(REWARD_SECOND_WEEK, JIM_AMOUNT, BOB_AMOUNT + JIM_AMOUNT),
                PRECISION,
                JIM_AMOUNT
            );
            assertEq(staking.navPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth), expectedMonthNav2);
        }

        // Expired share checkpoints track idle positions for each tier.
        assertEq(
            staking.cumulativeExpiredShares(TimeLockedStakingNFT.LockPeriod.OneDay),    Math.mulDiv(CAROL_AMOUNT, PRECISION, _entryNav(carolTokenId))
        );
        assertEq(
            staking.cumulativeExpiredSharesAtSlot(TimeLockedStakingNFT.LockPeriod.OneDay, 4 weeks),    Math.mulDiv(CAROL_AMOUNT, PRECISION, _entryNav(carolTokenId))
        );
        assertEq(
            staking.cumulativeExpiredShares(TimeLockedStakingNFT.LockPeriod.OneWeek), Math.mulDiv(ALICE_AMOUNT, PRECISION, _entryNav(aliceTokenId))
        );
        assertEq(
            staking.cumulativeExpiredSharesAtSlot(TimeLockedStakingNFT.LockPeriod.OneWeek, 4 weeks), Math.mulDiv(ALICE_AMOUNT, PRECISION, _entryNav(aliceTokenId))
        );
        assertEq(
            staking.cumulativeExpiredShares(TimeLockedStakingNFT.LockPeriod.OneMonth), Math.mulDiv(JIM_AMOUNT, PRECISION, _entryNav(jimTokenId))
        );
        assertEq(
            staking.cumulativeExpiredSharesAtSlot(TimeLockedStakingNFT.LockPeriod.OneMonth, 4 weeks), Math.mulDiv(JIM_AMOUNT, PRECISION, _entryNav(jimTokenId))
        );

        // The only active shares were KATE's renewed deposit.
        uint256 carolEntryNavFinal = _entryNav(carolTokenId);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneDay),
            Math.mulDiv(CAROL_AMOUNT, PRECISION, carolEntryNavFinal)
        );
        uint256 aliceEntryNavFinal = _entryNav(aliceTokenId);
        uint256 kateEntryNavFinal = _entryNav(kateTokenId);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneWeek),
            Math.mulDiv(ALICE_AMOUNT, PRECISION, aliceEntryNavFinal)
                + Math.mulDiv(KATE_AMOUNT, PRECISION, kateEntryNavFinal)
        );
        uint256 jimEntryNavFinal = _entryNav(jimTokenId);
        assertEq(
            staking.totalSharesPerTier(TimeLockedStakingNFT.LockPeriod.OneMonth),
            Math.mulDiv(JIM_AMOUNT, PRECISION, jimEntryNavFinal)
        );
        assertEq(staking.rewardDust(), 0);
        assertEq(token.balanceOf(address(rewardSource)), 0);
    }

    function _entryNav(uint256 tokenId) internal view returns (uint256) {
        return staking.getPosition(tokenId).entryNav;
    }

    function _unlock(uint256 tokenId) internal view returns (uint256) {
        return staking.getPosition(tokenId).unlockTimestamp;
    }

    function _defaultBoostFactors() internal pure returns (uint256[] memory factors) {
        factors = new uint256[](3);
        factors[0] = 100;
        factors[1] = 105;
        factors[2] = 110;
    }
}
